# 第 28 章 I/O 限制的异步操作

本章内容：

* <a href="#28_1">Windows 如何执行 I/O 操作</a>
* <a href="#28_2">C# 的异步函数</a>
* <a href="#28_3">编译器如何将异步函数转换成状态机</a>
* <a href="#28_4">异步函数扩展性</a>
* <a href="#28_5">异步函数和事件处理程序</a>
* <a href="#28_6">FCL 的异步函数</a>
* <a href="#28_7">异步函数和异常处理</a>
* <a href="#28_8">异步函数和其他功能</a>
* <a href="#28_9">应用程序及其线程处理模型</a>
* <a href="#28_10">以异步方式实现服务器</a>
* <a href="#28_11">取消 I/O 操作</a>
* <a href="#28_12">有的 I/O 操作必须同步进行</a>
* <a href="#28_13">I/O 请求优先级</a>

第 27 章重点讲述了如何异步执行计算限制的操作，允许线程池在多个 CPU 内核上调度任务，使多个线程能并发工作，从而高效率地使用系统资源，同时提升应用程序的吞吐能力。本章重点讲述如何异步执行 I/O 限制的操作，允许将任务交由硬件设备处理，期间完全不占用线程和 CPU 资源。然而，线程池仍然扮演了一个重要的角色，因为如同你马上就要看到的那样，各种 I/O 操作的结果还是要由线程池线程来处理的。

## <a name="28_1">28.1 Windows 如何执行 I/O 操作</a>

首先讨论 Windows 如何执行同步 I/O 操作。图 28-1 是连接了几个硬件设备的计算机系统。每个硬件设备都有自己的电路板，每个电路板都集成了一个小型的、特殊用途的计算机，它知道如何控制自己的硬件设备。例如，硬盘驱动器就有一个小的电路板，它知道如何旋转碟片、寻道、在碟上读写数据以及和计算机内存交换数据。

![28_1](../resources/images/28_1.png)  

图 28-1 Windows 如何执行执行同步 I/O 操作

程序通过构造一个 `FileStream` 对象来打开磁盘文件，然后调用 `Read` 方法从文件中读取数据。调用 `FileStream` 的 `Read` 方法时，你的线程从托管代码转变为本机/用户模式代码，`Read` 内部调用 Win32 `ReadFile` 函数(①)。`ReadFile` 分配一个小的数据结构，称为 I/O 请求包(I/O Request Packet, IRP)(②)。IRP 结构初始化后包含的内容有：文件句柄，文件中的偏移量(从这个位置开始读取字节)，一个 `Byte[]` 数组的地址(数组用读取的字节来填充)，要传输的字节数以及其他常规性内容。

然后，`ReadFile` 将你的线程从本机/用户模式代码，向内核传递 IRP 数据结构，从而调用 Windows 内核(③)。根据 IRP 中的设备句柄， Windows 内核知道 I/O 操作要传送给哪个硬件设备。因此，Windows 将 IRP 中的设备句柄，Windows 内核知道 I/O 操作要传送给哪个硬件设备。因此，Windows 将 IRP 传送给恰当的设备驱动程序的 IRP 队列(④)。每个设备驱动程序都维护着自己的 IRP 队列，其中包含了机器上运行的所有进程发出的 I/O 请求。IRP 数据包到达时，设备驱动程序将 IRP 信息传给物理硬件设备上安装的电路板。现在，硬件设备将执行请求的 I/O 操作(⑤)。

但要注意一个重要问题；在硬件设备执行 I/O 操作期间，发出了 I/O 请求的线程将无事可做，所以 Windows 将线程变成睡眠状态，防止它浪费 CPU 时间(⑥)。这当然很好。但是，虽然线程不浪费时间，但它仍然浪费了空间(内存)，因为它的用户模式栈、内核模式栈、线程环境块(thread environment block，TEB)和其他数据结构都还在内存中，而且完全没有谁去访问这些东西。这当然就不好了。

最终，硬件设备会完成 I/O 操作。然后，Windows 会唤醒你的线程，把它调度给一个 CPU，使它从内核模式返回用户模式，再返回至托管代码(⑦，⑧和⑨)。`FileStream` 的 `Read` 方法现在返回一个 `Int32`，指明从文件中读取的实际字节数，使你知道在传给 `Read` 的 `Byte[]` 中，实际能检索到多少个字节。

假定要实现一个 Web 应用程序，每个客户端请求抵达服务器时，都需要发出一个数据库请求。客户端请求抵达时，一个线程池线程会调用你的代码。如果以同步方式发出数据库请求，线程会阻塞不确定的时间，等待数据库返回结果。在此期间，如果另一个客户端请求抵达，线程池会创建另一个线程，这个线程在发出另一个数据库请求后，同样会阻塞。随着越来越多的客户端请求抵达，创建的线程也越来越多，所有这些线程都阻塞并等待数据库的响应。结果是 Web 服务器分配的系统资源(线程及其内存)基本上都浪费了！

更糟的是，当数据库用结果来响应请求时，线程会被解锁，全都开始执行。但由于可能运行了大量线程，同时 CPU 内核只有区区几个，所以 Windows 被迫执行频繁的上下文切换，这进一步损害了性能。这和实现一个可伸缩应用程序的初衷是完全背道而驰的。

现在讨论一下 Windows 如何执行异步 I/O 操作。图 28-2 删除了除硬盘之外的所有硬件设备，引入了 CLR 的线程池，稍微修改了代码。打开磁盘文件的方式仍然是通过构造一个 `FileStream` 对象，但现在传递了一个 `FileOptions.Asynchronous` 标志，告诉 Windows 我希望文件的读/写操作以异步方式执行。

![28_2](../resources/images/28_2.png)  

图 28-2 Windows 如何执行异步 I/O 操作

现在调用 `ReadAsync` 而不是 `Read` 从文件中读取数据。`ReadAsync` 内部分配一个 `Task<Int32>` 对象来代表用于完成读取操作的代码。然后，`ReadAsync` 调用 Win32 `ReadFile` 函数(①)。`ReadFile` 分配 IRP，和前面的同步操作一样初始化它(②)，然后把它传给 Windows 内核(③)。Windows 把 IRP 添加到硬盘驱动程序的 IRP 队列中(④)。但线程不再阻塞，而是允许返回至你的代码。所以，线程能立即从 `ReadAsync` 调用中返回(⑤，⑥和⑦)。当然，此时 IRP 可能尚未出处理好，所以不能够在 `ReadAsync` 之后的代码中访问传递的 `Byte[]` 中的字节。



## <a name="28_2">28.2 C# 的异步函数</a>

## <a name="28_3">28.3 编译器如何将异步函数转换成状态机</a>

## <a name="28_4">28.4 异步函数扩展性</a>

## <a name="28_5">28.5 异步函数和事件处理程序</a>

## <a name="28_6">28.6 FCL 的异步函数</a>

## <a name="28_7">28.7 异步函数和异常处理</a>

## <a name="28_8">28.8 异步函数和其他功能</a>

## <a name="28_9">28.9 应用程序及其线程处理模型</a>

## <a name="28_10">28.10 以异步方式实现服务器</a>

## <a name="28_11">28.11 取消 I/O 操作</a>

## <a name="28_12">28.12 有的 I/O 操作必须同步进行</a>

## <a name="28_13">28.13 I/O 请求优先级</a>
