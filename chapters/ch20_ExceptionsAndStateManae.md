# 第 20 章 异常和状态管理

本章内容

* <a href="#20_1">定义“异常”</a>
* <a href="#20_2">异常处理机制</a>
* <a href="#20_3">`System.Exception` 类</a>
* <a href="#20_4">FCL 定义的异常类</a>
* <a href="#20_5">抛出异常</a>
* <a href="#20_6">定义自己的异常类</a>
* <a href="#20_7">用可靠性换取开发效率</a>
* <a href="#20_8">设计规范和最佳实践</a>
* <a href="#20_9">未处理的异常</a>
* <a href="#20_10">对异常进行调试</a>
* <a href="#20_11">异常处理的性能问题</a>
* <a href="#20_12">约束执行区域(CER)</a>
* <a href="#20_13">代码协定</a>

本章重点在于错误处理，但并非仅限与此。错误处理要分几个部分。首先要定义到底什么是错误。然后要讨论如何判断正在经历一个错误，以及如何从错误中恢复。这个时候，状态就成为一个要考虑的问题，因为错误常常在不恰当的时候发生。代码可能在状态改变的中途发生错误。这时需要将一些状态还原为改变之前的样子。当然，还要讨论代码如何通知调用者有错误发生。

在我看来，异常处理是 CLR 最薄弱的一个环节，造成开发人员在写托管代码时遇到许多问题。经过多年的发展，Microsoft 确实进行了一系列显著的改进来帮助开发人员处理错误。但我认为在获得一个真正良好、可靠的系统之前， Microsoft 仍有大量工作要做。针对未处理的异常、约束执行区域(constraind execution region, CER)、代码协定、运行时包装的异常以及未捕捉的异常，本章要讨论处理它们时的改进。

## <a name="20_1">20.1 定义"异常"</a>

设计类型时要想好各种使用情况。类型名称通常是名词，例如 `FileStream` 或者 `StringBuilder`。 然后要为类型定义属性、方法、事件等。这些成员的定义方式(属性的数据类型、方法的参数、返回值等)就是类型的编程接口。这些成员代表本身或者类型实例能执行的行动。行动成员通常用动词表示，例如 `Read`，`Write`，`Flush`，`Append`，`Insert` 和 `Remove`等。当行动成员不能完成任务时，就应抛出异常。

> 重要提示 异常时指成员没有完成它的名称所宣称的行动。

例如以下类定义：

```C#
internal class Account {
    public static void Transfer(Account from, Account to, Decimal amount) {
        from -= amount;
        to += amount;
    }
}
```

`Transfer` 方法接受两个 `Account` 对象和一个代表账号之间转账金额的 `Decimal` 值。显然，`Transfer` 方法的作用是从一个账户扣除钱，把钱添加到另一个账户中。`Transfer` 方法可能因为多种原因而失败。例如，`from`或`to`实参可能为`null`; `from` 或 `to` 实参引用的可能不是活动账户；`from` 账户可能没有足够的资金；`to`账户的资金可能过多，以至于增加资金时导致账户溢出；`amount` 实参为 `0`、负数或者小数超过两位。

`Transfer` 方法在调用时，它的代码应检查前面描述的种种可能。检测到其中任何一种可能都不能转账，应抛出异常来通知调用者它不能完成任务。事实上，`Transfer` 方法的返回类型为 `void`。 这是由于 `Transfer` 方法没有什么有意义的值需要返回。这一点很容易想得通：方法正常返回<sup>①</sup>表明转账成功，失败就抛出一个有意义转账成功，失败就抛出一个有意义的异常。

> ① 指返回到调用位置，而不是返回一个值。————译注

面向对象编程极大提高了开发人员的开发效率，因为可以写这样的代码：

`Boolean f = "Jeff".Substring(1, 1).ToUpper().EndWith("E");    // true`

这行代码将多个操作链接到一起<sup>②</sup>。我很容易写这行代码，其他人也很容易阅读和维护，因为它的意图很明显：获取字符串，取出一部分，全部大写那个部分，然后检查那个部分是否”E“结尾。出发点不错，但有一个重要的前提：没有操作失败，中途不出错。但错误总是可能发生的，所以需要以一种方式处理错误。事实上，许多面向对象的构造——构造器、获取和设置属性、添加和删除事件、调用操作符重载和调用转换操作符等———都没办法返回错误代码，但它们仍然需要报告错误。Microsoft .NET Framework 和所有编程语言通过**异常处理**来解决这个问题。

> ② 事实上，利用 C# 的”扩展方法“，可以将更多本来不能链接的方法链接到一起。

> 重要提示 许多开发人员都错误地认为异常和某件事件的发生频率有关。例如，一个设计文件 `Read` 方法的开发人员可能会这样想：”读取文件最终会抵达文件尾。由于抵达文件尾部是会发生，所以我设计这个`Read`方法返回一个特殊值来报告抵达了文件尾；我不让它抛出异常。“
问题在于，这是设计 `Read` 方法的开发人员的想法，而非调用 `Read` 方法的开发人员的想法。

> 设计 `Read` 方法的开发人员不可能知道这个方法的所有调用情形。所以，开发人员不可能知道 `Read` 的调用者是不是每次都会一路读取到文件尾。事实上，由于大多数文件包含的都是结构化数据，所以一路读取直至文件尾的情况是很少发生的。

## <a name="20_2">20.2 异常处理机制</a>

本节介绍异常处理机制，以及进行异常处理所需的 C# 构造，但不打算罗列过多的细节。本章旨在提供何时以及如何使用异常处理的设计规范。要更多地了解异常处理机制和相关的 C# 语言结构，请参考文件和 C# 语言规范。另外， .NET Framework 异常处理机制是用 Microsoft Windows 提供的结构化异常处理(Structured Exception Handling, SEH)机制构建的。对 SEH 的讨论有很多，包括我自己的 《Windows 核心编程(第 5 版)》 一书，其中有 3 章内容专门讨论 SEH。

以下 C# 代码展示了异常处理机制的标准用法，可通过它对异常处理代码块及其用途产生初步认识。代码后面的各小节将正式描述 `try`、`catch` 和 `finally` 块及其用途，并提供关于它们的一些注意事项。

```C#
private void SomeMethod() {

    try {
        // 需要得体地进行恢复和/或清理的代码放在这里
    }
    catch (InvalidOperationException) {
        // 从 InvalidOperationException 恢复的代码放在这里
    }
    catch (IOException) {
        // 从 IOException 恢复的代码放在这里
    }
    catch {
        // 从除了上述异常之外的其他所有异常恢复的代码放在这里
        ...
        // 如果什么异常都捕捉，通常要重新抛出异常。本章稍后将详细解释
        throw；
    }
    finally {
        // 这里的代码对始于 try 块的任何操作进行清理
        // 这里的代码总是执行，不管是不是抛出了异常
    }
    // 如果 try 块没有抛出异常，或者某个 catch 块捕捉到异常，但没有抛出或
    // 重新抛出异常，就执行下面的代码
    ...
}
```

这段代码只是使用各种异常处理块的一种可能的方式。不要被这些代码吓到————大多数方法都只有一个 `try` 块和一个匹配 `finally` 块，或者一个 `try` 块和一个匹配 `finally` 块，或者一个 `try` 块和一个匹配的 `catch` 块。像本例那样有这么多 `catch` 块是很少见的，这里列出它们仅仅是为了演示。

### 20.2.1 `try`块

如果代码需要执行一般性的资源清理操作，需要从异常中恢复，或者两者都需要，就可以放到 `try` 块中。负责清理的代码应放到一个 `finally` 块中。 `try` 块还可包含也许会抛出异常的代码。负责异常恢复的代码应放到一个或多个 `catch`块中。针对应用程序能从中安全恢复的每一种异常，都应该创建一个 `catch` 块。一个 `try` 块至少要有一个关联的 `catch` 块或 `finally` 块，单独一个 `try` 块没有意义， C# 也不允许。

