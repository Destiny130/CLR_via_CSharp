# 第 12 章 泛型

本章内容

* <a href="12_1">FCL 中的泛型</a>
* <a href="12_2">泛型基础结构</a>
* <a href="12_3">泛型接口</a>
* <a href="12_4">泛型委托</a>
* <a href="12_5">委托和接口的逆变和协变泛型类型实参</a>
* <a href="12_6">泛型方法</a>
* <a href="12_7">泛型和其他成员</a>
* <a href="12_8">可验证性和约束</a>

熟悉面向对象编程的开发人员都深谙这种编程方式的好处。其中一个好处是“代码重用”，它极大提高了开发效率。也就是说，可以派生出一个类，让它继承基类的所有能力。派生类只需重写虚方法，或添加一些新方法，就可定制派生类的行为，使之满足开发人员的需求。**泛型**(generic)是 CLR 和编程语言的一种特殊机制，它支持另一种形式的代码重用，即“算法重用”。

简单地说，开发人员先定义好算法，比如排序、搜索、交换、比较或者转换等。但是，定义算法的开发人员并不设定该算法要操作什么数据类型；该算法可广泛地应用于不同类型的对象。然后，另一个开发人员只要指定了算法要操作的具体数据类型，就可以开始使用这个算法了。例如，一个排序算法可操作`Int32` 和 `String` 等类型的对象，而一个比较算法可操作`DateTime`和`Version`等类型的对象。

大多数算法都封装在一个类型中，CLR 允许创建泛型引用类型和泛型值类型，但不允许创建泛型枚举类型。此外，CLR 还允许创建泛型接口和泛型委托。方法偶尔也封装有用的算法，所以 CLR 允许在引用类型、值类型或接口中定义泛型方法。

先来看一个简单的例子。Framework 类库(Framework Class Library，FCL)定义了一个泛型列表算法，它知道如何管理对象集合。泛型算法没有设定对象的数据类型。要在使用这个泛型列表算法时指定具体数据类型。

封装了泛型列表算法的FCL类称为 `List<T>`(读作 List of Tee)。这个类是在 `System.Collections.Generic` 命名空间中定义的。下面展示了类定义(代码被大幅简化)：

```C#

```
