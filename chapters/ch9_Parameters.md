# 第 9 章 参数

本章内容：

* <a href="#9_1">可选参数和命名参数</a>
* <a href="#9_2">隐式类型的局部变量</a>
* <a href="#9_3">以传引用的方式向方法传递参数</a>
* <a href="#9_4">向方法传递可变数量的参数</a>
* <a href="#9_5">参数和返回类型的设计规范</a>
* <a href="#9_6">常量性</a>

本章重点在于向方法传递的各种方式，包括如何可选地指定参数，按名称指定参数，按名称指定参数，按引用传递参数，以及如何定义方法来接受可变数量的参数。

## <a name="9_1">9.1 可选参数和命名参数</a>

设计方法的参数时，可为部分或全部参数分配默认值。然后，调用这些方法的代码可以选择不提供部分实参，使用其默认值。此外，调用方法时刻通过指定参数名称来传递参数。以下代码演示了可选参数和命名参数的用法：

```C#
using System;
public static class Program {
    private static Int32 s_n = 0;

    private static void M(Int32 x = 9, String s = "A", 
        DateTime dt = default(DateTime), Guid guid = new Guid()) {

        Console.WriteLine("x={0}, s={1}, dt={2}, guid={3}", x, s, dt, guid);
    }

    public static void Main() {
        // 1. 等同于M(9, "A", default(DateTime), new Guid());
        M();

        // 2. 等同于M(8, "X", default(DateTime), new Guid());
        M(8, "X");

        // 3. 等同于M(5, "A", default(DateTime),Guid.NewGuid());
        M(5, guid: Guid.NewGuid(), dt: DateTime.Now);

        // 4. 等同于M(0, "1", default(DateTime), new Guid());
        M(s_n++, s_n++.ToString());

        // 5. 等同于以下两行代码：
        // String t1 = "2"; Int32 t2 = 3;
        // M(t2, t1, default(DateTime), new Guid());
        M(s: (s_n++).ToString(), x: s_n++);
    }
}
```

运行程序得到以下输出：

```cmd
x=9, s=A, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=8, s=X, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=5, s=A, dt=1/1/2021 3:34:58 PM, guid=372cba1a-01db-4570-945e-33e066882919
x=0, s=1, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=3, s=2, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
```

如你所见，如果调用时省略了一个实参，C#编译器会自动嵌入参数的默认值。对 `M` 的第 3 个和第 5 个调用使用了C# 的命名参数功能。在这两个调用中，我为 `x` 显式传递了值，并指出要为名为 `guid` 和 `dt` 的参数传递实参。

向方法传递实参时，编译器按从做到右的顺序对实参进行求值。在对 `M` 的第 4 个调用中，`s_n` 的当前值`(0)`传给`x`，然后`s_n`递增。随后，`s_n` 的当前值`(1)`作为字符串传给`s`，然后继续递增到`2`。使用命名参数传递实参时，编译器仍然按从左到右的顺序对实参进行求值。在对`M` 的第5 个调用中，`s_n`中当前值`(2)`被转换成字符串，并保存到编译器创建的临时变量`(t1)`中。接着，`s_n`递增到`3`，这个值保存到编译器创建的另一个临时变量`(t2)`中。然后，`s_n`继续递增到`4`。最后在调用`M`时，向它传递的实参依次是`t2`，`t1`，一个默认`DateTime`和一个新建的`Guid`。

### 9.1.1 规则和原则

如果在方法中为部分参数指定了默认值，请注意以下附加的规则和原则。

* 可为方法、构造器方法和有参属性(C#索引器)的参数指定默认值。还可以属于委托定义一部分的参数指定默认值。以后调用该委托类型的变量时可省略实参来接受默认值。

* 有默认值的参数必须放在没有默认值的所有参数之后。换言之，一旦定义了有默认值的参数，它右边的所有参数也必须有默认值。例如在前面的`M`方法定义中，如果删除`s`的默认值`("A")`，就会出现编译错误。但这个规则有一个例外：“参数数组”<sup>①</sup>这种参数必须放在所有参数(包括有默认值的这些)之后，而且数组本身不能有一个默认值。
> ① 在本章后面 9.4 节“向方法传递可变数量的参数”详细讨论。

* 默认值必须是编译时能确定的常量值。那么，哪些参数能设置默认值？这些参数的类型可以是C# 认定的基元类型(参见第 5 章的表 5-1)。还包括枚举类型，以及能设为`null`的任何引用类型。值类型的参数可将默认值设为值类型的实例，并让它的所有字段都包含零值。可以用 `default` 关键字或者 `new`关键字来表达这个意思；两种语法将生成完全一致的 IL 代码。在 `M` 方法中设置 `dt`参数和 `guid` 参数的默认值时，分别使用的就是这两种语法。

* 不要重命名参数变量，否则任何调用者以传参数名的方式传递实参，它们的代码也必须修改。例如，在前面的`M`方法声明中，如果将`dt`变量重命名为`dateTime`，对`M`的第三个调用就会造成编译器显示以下消息：`error CS1739:"M"的最佳重载没有名为"dt"的参数`。

* 如果方法从模块外部调用，更改参数的默认值具有潜在的危险性。call site<sup>①</sup>在它的调用中嵌入默认值。如果以后更改了参数的默认值，但没有重新编译包含 call site 的代码，它在调用你的方法时就会传递旧的默认值。可考虑将默认值`0/null`作为哨兵值使用，从而指出默认行为。这样一来，即使更改了默认值，也不必重新编译包含了 call site 的全部代码。下面是一个例子：
  > ① call site 是发出调用的地方，可理解成调用了一个目标方法的表达式或代码行。 ——译注
```C#
// 不要这样做：
private static String MakePath(String filename = "Untitled") {
    return String.Format(@"C:\{0}.txt", filename);
}

// 而要这样做：
private static String MakePath(String filename = null) {
    // 这里使用了空接合操作符(??)；详情参见第 19 章
    return String.Format(@"C:\{0}.txt", filename ?? "Untitled");
}
```

* 如果参数用`ref`或`out`关键字进行了标识，就不能设置默认值。因为没有办法为这些参数传递有意义的默认值。

使用可选或命名参数调用方法时，还要注意以下附加的规则和原则。

* 实参可按任意顺序传递，但命名实参只能出现在实参列表的尾部。

* 可按名称将实参传给没有默认值的参数，但所有必须的实参都必须传递(无论按位置还是按名称)，编译器才能编译代码。

* C# 不允许省略逗号之间的实参，比如 `M(1, , DateTime.Now)`。因为这会造成对可读性的影响，程序员将被迫去数逗号。对于有默认值的参数，如果想省略它们的实参，以传参数名的方式传递实参即可。

* 如果参数要求 `ref/out`，为了以传参数名的方式传递实参，请使用下面这样的语法：

```C#
// 方法声明
private static void M(ref Int32 x) { ... }

// 方法调用：
Int32 a = 5;
M(x: ref a);
```

> 注意 写 C# 代码和 Microsoft Office 的 COM 对象模型进行互操作性时，C# 的可选参数和命名参数功能非常好用。另外，调用 COM 组件时，如果是以传引用的方式传递实参，C# 还允许省略 `ref/out`，进一步简化编码。但如果调用的不是 COM 组件，C# 就要求必须向实参应用 `ref/out` 关键字。

### 9.1.2 `DefaultParameterValueAttribute` 和 `OptionalAttribute`

默认和可选参数的概念要不是 C# 特有的就好了！具有地说，我们希望程序员能用一种编程语言定义一个方法，指出哪些参数是可选的，以及它们的默认值是什么。然后，另一种语言的程序员可以调用该方法。要实现这一点，所选的编译器必须允许调用者忽略一些实参，还必须能确实这些实参的默认值。

在 C# 中，一旦为参数分配了默认值，编译器就会在内部向该参数应用定制特性`System.Runtime.InteropServices.OptionalAttribute`。该特性会在最终生成的文件的元数据中持久性地存储下来。此外，编译器向参数应用 `System.Runtime.InteropServices.DefaultParameterValueAttribute` 特性，并将该属性持久性存储到生成的文件的元数据中。然后，会向 `DefaultParameterValueAttribute` 的构造器传递你在源代码中指定的常量值。

之后，一旦编译器发现某个方法调用缺失了部分实参，就可以确定省略的是可选的实参，并从元数据中提取默认值，将值自动嵌入调用中。

## <a name="9_2">9.2 隐式类型的局部变量</a>

C# 能根据初始化表达式的类型推断方法中的局部变量的类型，如下所示：

```C#
private static void ImplicitlyTypeLocalVariables() {
    var name = "Jeff";
    ShowVariableType(name);                         // 显示：System.String

    // var n = null;                                // 错误，不能将 null 赋给隐式类型的局部变量
    var x = (String)null;                           // 可以这样写，但愿意不大
    ShowVariableType(x);                            // 显示：System.String

    var numbers = new Int32[] { 1, 2, 3, 4 };
    ShowVariableType(numbers);                      // 显示：System.Int32[]

    // 复杂类型能少打一些字
    var collection = new Dictionary<String, Single>() { { "Grant", 4.0f } };

    // System.Collections.Generic.Dictionary`2[System.String,System.Single]
    ShowVariableType(collection);

    foreach (var item in collection) {
        // 显示：System.Collections.Generic.KeyValuePair`2[System.String,System.Single]
        ShowVariableType(item);
    }
}

private static void ShowVariableType<T>(T t) {
    Console.WriteLine(typeof(T));
}
```

`ImplicitlyTypeLocalVariables` 方法中的第一行代码使用C#的`var`关键字引入了一个新的局部变量。为了确定`name`变量的类型，编译器要检查赋值操作符(=)右侧的表达式的类型。由于`"Jeff"`是字符串，所以编译器推断`name`的类型是`String`。为了证明编译器正确推断出类型，我写了`ShowVariableType` 方法。这个泛型方法推断它的实参的类型并在控制台上显示。为方便阅读，我在 `ImplicitlyTypeLocalVariables` 方法内以注释形式列出了每次调用`ShowVariableType`方法的显示结果。

`ImplicitlyTypeLocalVariables` 方法内部的第二个赋值(被注释掉了)会产生编译错误`:error CS0815:无法将“<null>”赋予隐式类型的局部变量`。这是由于 `null` 能隐式转型为任何引用类型或可空值类型。因此，编译器不能推断它的确切类型。但在第三个赋值语句中，我证明只要显式指定了类型(本例是 `String`)，就可以将隐式类型的局部变量初始化为 `null`。这样做虽然可行，但意义不大，因为可以写 `String x = null;`来获得同样效果。

第 4 个赋值语句反映了 C# “隐式类型局部变量”功能的真正价值。没有这个功能，就不得不在赋值操作符的左右两侧指定 `Dictionary<String, Single>`。这不仅需要打更多的字，而且以后修改了集合类型或者任何泛型参数类型，赋值操作符两侧的代码也要修改。

在`foreach`循环中，我用`var`让编译器自动推断集合中的元素的类型。这证明了`var`能很好地用于`foreach`，`using`和`for`语句。还可在验证代码时利用它。例如，可以用方法的返回值初始化隐式类型的局部变量。开发方式时可以灵活更改返回类型。编译器能察觉到返回类型的变化，并自动更改变量的类型！当然，如果使用变量的代码没有相应地进行修改，还是像使用旧类型那样使用它，就可能无法编译。

在 Microsoft Visual Studio 中，鼠标放到 `var` 上将显示一条“工具提示”，指出编译器根据表达式推断出来的类型。在方法中使用匿名类型时必须用到C#的隐式类型局部变量，详情参见第 10 章“属性”。

不能用`var`声明方法的参数类型。原因显而易见，因为编译器必须根据在call site传递的实参来推断参数类型，但 call site 可能一个都没有，也可能有好多个<sup>①</sup>。除此之外，不能用`var`声明类型中的字段。C# 的这个限制是出于多方面的考虑。一个原因是字段可以被多个方法访问，而 C# 团队认为这个协定(变量的类型)应该显式陈述。另一个原因是一旦允许，匿名类型(第 10 章)就会泄露到方法的外部。
> ① 要么一个类型都推断不出来，要么多个推断发生冲突。 ——译注

>重要提示 不要混淆`dynamic`和`var`。用`var`声明局部变量只有一种简化语法，它要求编译器根据表达式推断具体数据类型。`var`关键字只能声明方法内部的局部变量，而`dynamic`关键字适用于局部变量、字段和参数。表达式不能转型为`var`，但能转型为 `dynamic`。必须显式初始化用 `var`声明的变量，但无需初始化用 `dynamic` 声明的变量。欲知 C# `dynamic` 类型的详情，请参见 5.5 节 “`dynamic`基元类型"。

## <a name="9_3">9.3 以传引用的方式向方法传递参数</a>

CLR 默认所有方法参数都传值。传递引用类型的对象时，对象引用(或者说指向对象的指针)被传给方法。注意引用(或指针)本身是传值的，意味着方法能修改对象，而调用者能看到这些修改。对于值类型的实例，传给方法的是实例的一个副本，意味着方法将获得它专用的一个值类型实例副本，调用者中的实例不受影响。
>重要提示 在方法中，必须知道传递的每个参数是引用类型还是值类型，处理参数的代码显著有别。

CLR 允许以传引用而非传值的方式传递参数。