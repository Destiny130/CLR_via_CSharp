# 第 2 章 生成、打包、部署和管理应用程序及类型

本章内容：
* <a href="#2_1">.NET Framework 部署目标</a>
* <a href="#2_2">将类型生成到模块中</a>
* <a href="#2_3">元数据概述</a>
* <a href="#2_4">将模块合并成程序集</a>
* <a href="#2_5">程序集版本资源信息</a>
* <a href="#2_6">语言文化</a>
* <a href="#2_7">简单应用程序部署(私有部署的程序集)</a>
* <a href="#2_8">简单管理控制(配置)</a>

在解释如何为 Microsoft .Net Framework 开发程序之前，首先讨论一下生成、打包和部署应用程序及其类型的步骤。本章重点解释如何生成仅供自己的应用程序使用的程序集。第 3 章“共享程序集和强命名程序集”将讨论更高级的概念，包括如何生成和使用程序集，使其中包含的类型能由多个应用程序共享。这两章会谈及管理员能采用什么方式来影响应用程序及其类型的执行。

当今的应用程序都由多个类型构成，这些类型通常是由你的和 Microsoft 创建的。除此之外，作为一个新兴产业，组件厂商们也纷纷着手构建一些专用类型，并将其出售给各大公司，以缩短软件项目的开发时间。开发这些类型时，如果使用的语言是面向 CLR 的，这些类型就能无缝地共同工作。换言之，用一种语言写的类型可以将另一个类型作为自己的基类使用，不用关心基类用什么语言开发。

本章将解释如何生成这些类型，并将其打包到文件中以进行部署。另外，还会提供一个简短的历史回顾，帮助开发人员理解 .NET Framework 希望解决的某些问题。

## <a name="2_1">2.1 .NET Framework 部署目标</a>

Windows 多年来一直因为不稳定和过于复杂而口碑不佳。不管对它的评价对不对，之所以造成这种状况，要归咎于几方面的原因。首先，所有应用程序都使用来自 Microsoft 或其他厂商的动态链接库(Dynamic-Link Library,DLL)，由于应用程序要执行多个厂商的代码，所以任何一段代码的开发人员都不能百分之百保证别人以什么方式使用这段代码。虽然这种交互可能造成各种各样的麻烦，但实际一般不会出太大问题，因为应用程序在部署前会进行严格测试和调试。

但对于用户，当一家公司决定更新其软件产品的代码，并将新文件发送给他们时，就可能出问题。新文件理论上应该向后兼容以前的文件，但谁能对此保证呢？事实上，一家厂商更新代码时，经常都不可能重新测试和调试之前发布的所有应用程序，无法保证自己的更改不会造成不希望的结果。

很多人都可能遭遇过这样的问题：安装新应用程序时，它可能莫名其妙破坏了另一个已经安装好的应用程序。这就是所谓的“DLL hell”。这种不稳定会对普通计算机用户带来不小的困扰。最终结果是用户必须慎重考虑是否安装新软件。就像我个人来说，有一些重要的应用程序是平时经常都要用到的，为了避免对它们产生不好的影响，我不会冒险去”尝鲜“。

造成 Windows 口碑不佳的第二个原因是安装的复杂性，如今，大多数应用程序在安装时都会影响到系统的全部组件。例如，安装一个应用程序会将文件复制到多个目录，更新注册表设置，并在桌面和”开始“菜单上安装快捷方式。问题是，应用程序不是一个孤立的实体。应用程序备份不易，因为必须复制应用程序的全部文件以及注册表中的相关部分。除此之外，也不能轻松地将应用程序从一台机器移动到另一台机器。只有再次运行安装程序，才能确保所有文件和注册表设置的正确性。最后，即使卸载或移除了应用程序，也免不了担心它的一部分内容仍潜伏在我们的机器中。

第三个原因涉及到安全性。应用程序安装时会带来各种文件，其中许多是由不用的公司开发的。此外， Web 应用程序经常悄悄下载一些代码(比如 ActiveX 控件)，用户根本注意不到自己打的机器上安装了这些代码。如今，这种代码能够执行任何操作，包括删除文件或者发送电子邮件。用户完全有理由害怕安装新的应用程序，因为它们可能造成各种各样的危害。考虑到用户的感受，安全性必须集成到系统中，使用户能够明确允许或禁止各个公司开发的代码访问自己的系统资源。

阅读本章和下一章可以知道， .NET Framework 正常尝试彻底解决 DLL hell 的问题。另外， .NET Framework 还在很大程度上解决了应用程序状态在用户硬盘上四处分散的问题。例如，和 COM 不同，类型不再需要注册表中的设置。但遗憾的是，应用程序还是需要快捷方式。安全性方面，.NET Framework 包含称为”代码访问安全性“(Code Access Security)的安全模型。 Windows 安全性基于用户身份，而代码访问安全性允许宿主设置权限，控制加载的组件能做的事情。像 Microsoft SQL Server 这样的宿主应用程序只能将少许权限授予代码，而本地安装的(自宿主)应用程序可获得完全信任(全部权限)。以后会讲到，.NET Framework 允许用户灵活地控制那些东西能够安装，那些东西能够运行。他们对自己机器的控制上升到一个前所未有的高度。

## <a name="2_2">2.2 将类型生成到模块中</a>

本节讨论如何将包含多个类型的源代码文件转变为可以部署的文件。先看下面这个简单的应用程序。

```C#
public sealed class Program {
  public static void Main(){
      System.Console.WriteLine("Hi");
  }
}
```

该应用程序定义了 `Program` 类型，其中有名为 `Main` 的 `public static` 方法。`Main` 中引用了另一个类型 `System.Console`。 `System.Console` 是 Microsoft 实现好的类型，用于实现这个类型的各个方法的IL 代码存储在 `MSCorLib.dll` 文件中。总之，应用程序定义了一个类型，还使用了其他公司提供的类型。

为了生成这个示例应用程序，请将上述代码放到一个源代码文件中(假定为Program.cs)，然后再命令行执行以下命令： 

>`csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs`  

这个命令行指示 C# 编译器生成名为 Program.exe 的可执行文件 (`/out:Prpgram.exe`)。生成的文件是 Win32 控制台应用程序类型 (`/t\[arget\]:exe`)。  

C# 编译器处理源文件时，发现代码引用了 `System.Console`类型的 `WriteLine` 方法。此时，编译器要核实该类型确实存在，它确实有 `WriteLine` 方法，而且传递的实参与方法形参匹配。由于该类型在 C# 源代码中没有定义，所以要顺利通过编译，必须向 C# 编译器提供一组程序集，使它能解析对外部类型的引用。在上述命令行中，我添加了 `/r[eference]:MSCorLib.dll` 开关，告诉编译器在 `MSCorLib.dll` 程序集中查找外部类型。

`MSCorLib.dll` 是特殊文件，它包含所有核心类型，包括 `Byte`，`Char`，`String`，`Int32` 等等。事实上，由于这些类型使用得如此频繁，以至于 C# 编译器会自动引用 `MSCorLib.dll` 程序集。换言之，命令行其实可以简化成下面这样(省略`/r`开关)：  

>`csc.exe /out:Program.exe /t:exe Program.cs`  

此外，由于`/out:Program.exe` 和 `/t:exe` 开关是 C# 编译器的默认规定，所以能继续简化成以下形式：  

>`csc.exe Program.cs`

如果因为某个原因不想 C# 编译器自动引用 `MSCorLib.dll` 程序集，可以使用`/nostdlib` 开关。 Microsoft 生成`MSCorLib.dll` 程序集自身时便使用了这个开关。例如，用以下命令行编译 `Program.cs` 会报错，因为它使用的 `System.Console` 类型是在`MSCorLib.dll`中定义的：  

>`csc.exe /out:Program.exe /t:exe /nostdlib Program.cs`

现在更深入地思考一下 C# 编译器生成的 `Program.exe` 文件。这个文件到底是什么？首先，它是标准PE (可移植执行体，Potable Executable)文件。这意味着运行 32 位或 64 位 Windows 的计算机能加载它，并通过执行某些操作。 Windows 文件支持三种应用程序。生成控制台用户界面(Console User Interface，CUI)应用程序使用`/t:exe` 开关；生成图形用户界面(Graphical User Interface，GUI)应用程序使用`/t:winexe` 开关；生成 Windows Store 应用使用 `/t:appcontainerexe` 开关。
