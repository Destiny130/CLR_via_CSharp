# 第 6 章 类型和成员基础

本章内容  
* <a href="#6_1">类型的各种成员</a>
* <a href="#6_2">类型的可见性</a>
* <a href="#6_3">成员的可访问性</a>
* <a href="#6_4">静态类</a>
* <a href="#6_5">分部类、结构和接口</a>
* <a href="#6_6">组件、多态和版本控制</a>

第 4 章和第 5 章重点介绍了类型以及所有类型的所有实例都支持的一组操作，并指出所有类型都可划分为引用类型或值类型。在本章及本部分后续的章节，将解释如何在类型中定义各种成员，从而设计出符合需要的类型。第 7 章 ~ 第 11 章将详细讨论各种成员。

## <a name="6_1">6.1 类型的各种成员</a>

类型中可定义 0 个或多个以下种类的成员。

* **常量** 常量是指出数据值恒定不变的符号。这种符号使代码更易阅读和维护。常量总与类型关联，不于类型的实例关联。常量逻辑上总是静态成员。相关内容在第 7 章“常量和字段”讨论。

* **字段** 字段表示只读或可读的数据值。字段可以是静态的；这种字段被认为是*类型*状态的一部分。字段也可以是实例(非静态)；这种字段被认为是*对象*状态的一部分。强烈建议将字段声明为私有，防止类型或对象的状态被类型外部的代码破坏。相关内容在第 7 章讨论。

* **实例构造器** 实例构造器是将新*对象*的实例字段初始化为良好初始状态的特殊方法。相关内容在第 8 章“方法”讨论。

* **类型构造器** 类型构造器是将*类型*的静态字段初始化为良好初始状态的特殊方法。相关内容在第 8 章讨论。

* **方法** 方法是更改或查询类型或对象状态的函数。作用于类型称为静态方法，作用于对象称为实例方法。方法通常要读写类型或对象的字段。相关内容在第 8 章讨论。

* **操作符重载** 操作符重载实际是方法，定义了当操作符作用于对象时，应该如何操作该对象。由于不是所有编程语言都支持操作符重载，所以操作符重载方法不是“公共语言规范”(Common Language Specification， CLS)的一部分。相关内容在第 8 章讨论。

* **转换操作符** 转换操作符是定义如何隐式或显式将对象从一种类型转型为另一种类型的方法。和操作符重载方法一样，并不是所有编程语言都支持转换操作符，所以不是 CLS 的一部分。相关内容在第 8 章讨论。

* **属性** 属性允许用简单的、字段风格的语法设置或查询类型或对象的逻辑状态，同时保证状态不被破坏。作用于类型称为静态属性，作用于对象称为实例属性。属性可以无参(非常普遍)，也可以有多个参数(相当少见，但集合类用得多)。相关内容在第 10 章 “属性”讨论。

* **事件** 静态事件允许类型向一个或多个静态或实例方法发送通知。实例(非静态)事件允许对象向一个或多个静态或实例方法发送通知。引发事件通常是为了响应提供事件的类型或对象的状态的改变。事件包含两个方法，允许静态或实例方法登记或注销对该事件的关注。除了这两个方法，事件通常还用一个委托字段来维护已登记的方法集。相关内容在第 11 章“事件”讨论。

* **类型** 类型可定义其他嵌套类型。通常用这个办法将大的、复杂的类型分解成更小的构建单元(building block)以简化实现。

再次声明，本章总之并非详细描述各种成员，而是帮你打好基础，阐明这些成员的共性。

无论什么编程语言，编译器都必须能处理源代码，为上述每种成员生成元数据和 IL 代码。所有编程语言生成的元数据格式完全一致。这正是 CLR 成为“公共语言运行时” 的原因。元数据是所有语言都生成和使用的公共信息。这是由于有了元数据，用一种语言写的代码才能无缝访问用另一种语言写的代码。

CLR 还利用公共元数据格式决定常量、字段、构造器、方法、属性和事件在运行时的行为。简单地说，元数据是整个 Microsoft .NET Framework 开发平台的关键，它实现了编程语言、类型和对象的无缝集成。

以下 C# 代码展示了一个类型定义，其中包含所有可能的成员。代码能通过编译(有一些警告)，但不能代表你平常创建的类型。大多数方法没有实用价值，仅仅是为了示范编译器如何将类型及其成员转换成元数据。再次说明，后面几章会逐一对这些成员进行讨论。

```C#
using System;

public sealed class SomeType {                             // 1
    
    // 嵌套类
    private class SomeNestedType { }                       // 2
    // 常量、只读和静态可读/可写字段
    private const Int32 c_SomeConstant = 1;                // 3 

    private readonly String m_SomeReadOnlyField = "2";     // 4
    private static Int32 s_SomeReadWriteField = 3;         // 5

    // 类型构造器
    static SomeType() { }                                  // 6

    // 实例构造器
    public SomeType(Int32 x) { }                           // 7
    public SomeType() { }                                  // 8

    // 实例方法和静态方法
    private String InstanceMethod() { return null; }       // 9
    public static void Main() { }                          // 10
    
    // 实例属性
    public Int32 SomeProp {                                // 11
        get { return 0; }                                  // 12
        set { }                                            // 13
    }

    // 实例有参属性(索引器)
    public Int32 this[String s] {                          // 14
        get { return 0; }                                  // 15
        set { }                                            // 16
    }

    // 实例事件
    public event EventHandler SomeEvent;                   // 17
}
```

编译这个类型，用 ILDasm.exe 查看元数据，将看到如图 6-1 所示的输出。  
![6_1](../resources/images/6_1.png)  
图 6-1 用 ILDasm.exe 查看 SomeType 的元数据

注意，源代码中定义的所有成员都造成编译器生成元数据。事实上，有的成员还造成编译器生成额外的成员和额外的元数据。例如，事件成员(17)造成编译器生成一个字段、两个方法和一些额外的元数据。目前不理解这些内容没有关系。但在学习后面几章时，希望你能回头看看这个例子，体会成员是如何定义的，它们对编译器生成的元数据有何影响。

## <a name="6_2">6.2 类型的可见性</a>

要定义文件范围的类型(而不是将类型定义嵌套到另一个类型中)时，可将类型的可见性指定为 `public` 或 `internal`。`public`类型不仅对定义程序集中的所有代码可见，还对其他程序集中的代码可见。`internal` 类型则仅对定义程序集中的所有代码可见，对其他程序集中的代码不可见。定义类型时不显示指定可见性，C# 编译器会帮你指定为 `internal`(限制比`public`大)。下面是几个例子。

```C#
using System;

// 以下类型的可见性为 public，既可由本程序集中的代码访问，
// 也可由其他程序集中的代码访问
public class ThisIsAPublicType { ... }

// 以下类型的可见性为 internal，只可由本程序集中的代码访问
public class ThisIsAnInternalType { ... }

// 由于没有显式声明类型的可见性，所以以下类型的可见性为 internal
class ThisIsAlsoAnInternalType { ... }
```

#### 友元程序集

假定下述情形：某公司的团队 TeamA 在某个程序集中定义了一组工具类型(utility type)，并希望公司的另一个团队 TeamB 的成员使用这些类型。但由于各种原因，比如时间安排、地理位置、不同的成本中心或报表结构，这两个团队不能将他们的所有类型都生成到一个程序集中；相反，每个团队都生成都要生成自己的程序集。

为了使团队 TeamB 的程序集能使用团队 TeamA 的类型，TeamA 必须将他们的所有工具类型定义为 `public`。但这意味着工具类型对所有程序集公开。就连另一家公司的开发人员也能写代码使用它们。这不是公司所希望的。这些工具类型也许做出了一些预设，而 TeamB 写代码时会确保这些预设成立。我们希望 TeamB 访问这些类型。CLR 和 C# 通过 **友元程序集**(friend assembly)提供这方面的支持。用一个程序集中的代码对另一个程序集中的内部类型进行单元测试时，友元程序集功能也能派上用场。

生成程序集时，可用 `System.Runtime.CompilerServices` 命名空间中的 `InternalsVisibleTo` 特性标明它认为是“友元”的其他程序集。该特性获取标识友元程序集名称和公钥的字符串参数(传给该特性的字符串绝不能包含版本、语言文化和处理器架构)。注意当程序集认了“友元”之后，友元程序集就能访问该程序集中的所有 `internal` 类型，以及这些类型的 `internal` 成员。下例展示一个程序集如何将两个强命名程序集 “Wintellect” 和 “Microsoft” 指定为友元程序集：

```C#
using System;
using System.Runtime.CompilerServices;   // 为了 InternalsVisibleTo 特性

// 当前程序集中的 internal 类型可由以下两个程序集中
// 的任何代码访问(不管什么版本或语言文化)
[assembly:InternalsVisibleTo("Wintellect, PublicKey=12345678...90abcdef")]
[assembly:InternalsVisibleTo("Microsoft, PublicKey=b77a5c56...1934e089")]

internal sealed class SomeInternalType { ... }
internal sealed class AnotherInternalType { ... }
```

从友元程序集访问上述程序集的 `internal` 类型很容易。例如，下面展示了公钥为 “12345678...90abcdef”的友元程序集“Wintellect”如何访问上述程序集的 `internal` 类型 `SomeInternalType`。

```C#
using System;

internal sealed class Foo {
    private static Object SomeMethod() {
        // 这个“Wintellect” 程序集能访问另一个程序集的 internal 类型，
        // 就好像那时 public 类型
        SomeInternalType sit = new SomeInternalType();
        return sit;
    }
}
```

由于程序集中的类型的 `internal` 成员能从友元程序集访问，所以要慎重考虑类型成员的可访问性，以及要将哪些程序集声明为友元。注意 C# 编译器在编译友元程序集(不含`InternalsVisibleTo` 特性的程序集)时要求使用编译器开关 **/out:<*file*>**。使用这个编译器开关的原因在于，编译器需要知道准备编译的程序集的名称，从而判断生成的程序集是不是友元程序集。你或许以为 C# 编译器能自己判断，因为平时都是它自己确定输出文件名。但事实上，在代码结束编译之前，C# 编译器是不知道输出文件名的。因此，使用 **/out:<*file*>**编译器开关能极大增强编译性能。

同样地，如果使用C# 编译器的 **/t:module** 开关来编译模块(而不是编译成程序集)，而且该模块将成为某个友元程序集的一部分，那么还需要使用 C# 编译器的 **/moduleassemblyname:<*string*>** 开关来编译该模块，它告诉编译器该模块将成为哪个程序集的一部分，使编译器设置模块中的代码，使它们能访问另一个程序集中的 `internal` 类型。

## <a name="6_3">6.3 成员的可访问性</a>

定义类型的成员(包括嵌套类型)时，可指定成员的**可访问性**。在代码中引用成员时，成员的可访问性指出引用是否合法。CLR 自己定义了一组可访问性修饰符，但每种编程语言在向成员应用可访问性时，都选择了自己的一组术语以及相应的语法。例如，CLR 使用 `Assembly` 表明成员对同一程序集内的所有代码可见，而 C# 对应的术语是 `internal`。

表 6-1 总结了 6 个应用于成员的可访问性修饰符。从第一行到最后一行，按照从限制最大(`Private`)到限制最小(`Public`)的顺序排列。  

表 6-1 成员的可访问性
|CLR术语|C#术语|描述|
|:---:|:---:|:----:|
|`Private`| `private`|成员只能由定义类型或任何嵌套类型中的方法访问|
|`Family`|`protected`|成员只能由定义类型、任何嵌套类型或者不管在什么程序集中的派生类型中的方法访问|
|`Family and Assembly`|(不支持)|成员只能由定义类型、任何嵌套类型或者同一程序集中定义的任何派生类型中的方法访问|
|`Assembly`|`internal`|成员只能由定义程序集中的方法访问|
|`Family or Assembly`|`protected internal`|成员可由任何嵌套类型、任何派生类型(不管在什么程序集)或者定义程序集中的任何方法访问|
|`Public`|`public`|成员可由任何程序集的任何方法访问|

当然，任何成员要想被访问，都必须在可见的类型中定义。例如，如果程序集 AssemblyA 定义了含有一个 `public` 方法的 `internal` 类型，则程序集 AssemblyB 中的代码不能调用该 `public` 方法，因为 `internal` 类型对 AssemblyB 来说不可见。

编译代码时，编程语言的编译器检查代码是不是正确引用了类型和成员。如果代码不正确地引用了类型或成员，编译器会生成一条合适的错误消息。另外，在运行时将 IL 代码编译成本机 CPU 指令时，JIT 编译器也会确保对字段和方法的引用合法。例如，JIT 编译器如果检测到代码不正确地访问私有字段或方法，将分别抛出 `FieldAccessException` 或 `MethodAccessException` 异常。

通过对 IL 代码进行验证，可确保被引用成员的可访问性在运行时得到正确兑现——即使语言的编译器忽略了对可访问性的检查。另外极有可能发生的情况是：语言编译器编译的代码会访问另一个程序集中的另一个类型的 `public` 成员，但到运行时却加载了程序集的不同版本，新版本中的 `public` 成员变成了 `protected` 或 `private` 成员。

在 C# 中，如果没有显式声明成员的可访问性，编译器通常(但并不总是)默认选择 `private`(限制最大的那个)。CLR 要求接口类型的所有成员都具有 `public` 可访问性。C# 编译器知道这一点，因此禁止开发人员显式指定接口成员的可访问性；编译器自动将所有成员的可访问性设为 `public`。

> 更多信息 参考 C# 语言规范的“Declared Accessibility”(已声明可访问性)一节，完整地了解可在 C# 中向类型和成员应用哪些可访问性，以及如何根据声明的上下文来选择默认的可访问性。

你也许注意到了，CLR 提供了称为 `Family and Assembly` 的可访问性。但 C# 不支持。C# 开发团队认为这种可访问性基本没有，所以决定放弃。

派生类型重写重写基类型定义的成员时，C# 编译器要求原始成员和重写成员具有相同的可访问性。也就是说，如果基类成员是 `protected` 的，派生类中的重写成员也必须是 `protected` 的。但这是 C# 的限制，不是 CLR 的。从基类派生时，CLR 允许放宽但不允许收紧成员的可访问性限制。例如，类可重写基类定义的 `protected` 方法，将重写方法设为 `public`(放宽限制)。但不能重写基类定义的 `protected` 方法，将重写方法设为 `private`(收紧限制)。之所以不能在派生类中收紧对基类方法的访问，是因为 CLR 承诺派生类总能转型为基类，并获取对基类方法的访问权。如果允许派生类收紧限制，CLR 的承诺就无法兑现了。

##  <a name="6_4">6.4 静态类</a>

有一些永远不需要实例化的类，例如 `Console`，`Math`，`Environment` 和 `ThreadPool`。这些类只有 `static` 成员。事实上，这种类唯一的作用就是组合一组相关的成员。例如， `Math` 类就定义了一组执行数学运算的方法。在 C# 中，要用 `static` 关键字定义不可实例化的类。该关键字只能应用于类，不能应用于结构(值类型)。因为 CLR 总是允许值类型实例化，这是没办法阻止的。

C# 编译器对静态类进行了如下限制。

* 静态类必须直接从基类 `System.Object` 派生，从其他任何基类派生都没有意义。继承只适用于对象，而你不能创建静态类的实例。
* 静态类不能实现任何接口，这是因为只有使用类型的实例时，才可调用类的接口方法。
* 静态类只能定义静态成员(字段、方法、属性和事件)，任何实例成员都会导致编译器报错。
* 静态类不能作为字段、方法参数或局部变量使用，因为它们都代表引用了实例的变量，而这是不允许的。编译器检测到任何这样的用法都会报错。

下面是一个定义了静态成员的静态类。代码虽能通过编译(有一个警告)，但该类没有做任何有意义的事情。

```C#
using System;
public static class AStaticClass {
    public static void AStaticMethod() { }

    public static String AStaticProperty {
        get { return s_AStaticField; }
        set { s_AStaticField = value; }
    }

    private static String s_AStaticField;

    public static event EventHandler AStaticEvent;
}
```

将上述代码编译成库(DLL)程序集，用 ILDasm.exe 查看会得到如图 6-2 所示的结果。如你所见，使用关键字 `static` 定义类，将导致 C# 编译器将该类标记为 `abstract` 和 `sealed`。另外，编译器不在类型中生成实例构造器方法，你在图 6-2 中看不到实例构造器(.ctor)方法。  
![6_2](../resources/images/6_2.png)  
图 6-2 ILDasm.exe 表明静态类在元数据中是抽象密封类

## <a name="6_5">6.5 分部类、结构和接口</a>

本节要讨论分部类、结构和接口。`partial` 关键字告诉 C# 编译器；类、接口或接口的定义源代码可能要分散到一个或多个源代码文件中。将类型源代码分散到多个文件的原因有三。

* **源代码控制**  
  假定类型定义包含大量源代码，一个程序员把它从源代码控制系统中签出(check out)以进行修改。没有其他程序员能同时修改这个类型，除非之后执行合并(merge)。使用 `partial` 关键字可将类型的代码分散到多个源代码文件中，每个文件都可单独签出，多个程序员能同时编辑类型。

* **在同一个文件中将类或结构分解成不同的逻辑单元**
  我有时会创建一个类型来提供多个功能，使类型能提供完整解决方案。为简化实现，有时会在一个源代码文件中重复声明同一个分部类型。然后，分部类型的每个部分都实现一个功能，并配以它的全部字段、方法、属性、事件等。这样就可方便地看到组合以提供一个功能的全体成员，从而简化编码。与此同时，可以方便地将分部类型的一部分注释掉，以便从类中删除一个完整的功能，代之以另一个实现(通过分部类型的一个新的部分)。

* **代码拆分**
  在 Microsoft Visual Studio 中创建新项目时，一些源代码文件会作为项目一部分自动创建。这些源代码文件包含模板，能为项目开个好头。使用 Visual Studio 在设计图面上拖放空间时，Visual Studio 自动生成源代码，并将代码拆分到不同的源代码文件中。这提高了开发效率。很久以前，生成的代码是直接放到当前正在处理的那个源代码文件中的。这样做的问题在于，如果不小心编辑了一下生成的代码，设计器行为就可能失常。从 Visual Studio 2005 开始，新建窗体、控件等的时候，Visual Studio 自动创建两个源代码文件：一个用于你的代码，另一个用于设计器生成的代码。由于设计器的代码在单独的文件中，所以基本上杜绝了不小心编辑到它的可能。

要将 `partial` 关键字应用于所有文件中的类型。这些文件编译到一起时，编译器会合并代码，在最后的.exe 或 .dll 程序文件(或 .netmodule 模块文件)中生成单个类型。“分部类型”功能完全由 C# 编译器实现，CLR 对该功能一无所知，这解释了一个类型的所有源代码文件为什么必须使用相同编程语言，而且必须作为一个编译单元编译到一起。

## <a name="6_6">6.6 组件、多态和版本控制</a>

面向对象编程(Object-Oriented Programming，OOP)已问世多年。它在上个世纪 70 年代末、80 年代初首次投入应用时，应用程序规模还非常小，而且使应用程序运行起来所需的全部代码都由同一家公司编写。当然，那时确实有操作系统，应用程序也确实使用了操作系统的一些功能，但和今天的操作系统相比，那时的操作系统所提供的功能是在是太少了。

如今软件变得相当复杂，而且用户希望应用程序提供更丰富的功能，如 GUI、菜单、鼠标输入、手写板输入、打印输出、网络功能等。