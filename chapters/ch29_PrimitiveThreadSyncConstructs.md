# 第 29 章 基元线程同步构造

本章内容

* <a href="#29_1">类库和线程安全</a>
* <a href="#29_2">基元用户模式和内核模式构造</a>
* <a href="#29_3">用户模式构造</a>
* <a href="#29_4">内核模式构造</a>

一个线程池线程阻塞时，线程池会创建额外的线程，而创建、销毁和调度线程所需的时间和内存资源是相当昂贵的。另外，许多开发人员看见自己程序的线程没有做任何有用的事情时，他们的习惯是创建更多的线程，寄希望于新线程能做有用的事情。为了构建可伸缩的、响应灵敏的应用程序，关键在于不要阻塞你拥有的线程，使它们能用于(和重用于)执行其他任务。第 27 章“计算限制的异步操作”讲述了如何利用线程执行计算限制的操作，第 28 章 “I/O 限制的异步操作” 则讲述了如何利用线程执行 I/O 限制的操作。

本章重点在于线程同步。多个线程**同时**访问共享数据时，线程同步能防止数据损坏。之所以要强调**同时**，是因为线程同步问题其实就是计时问题。如果一些数据由两个线程访问，但那些线程不可能同时接触到数据，就完全用不着线程同步。第 28 章展示了如何通过不同的线程来执行异步函数的不同部分。可能有两个不同的线程访问相同的变量和数据，但根据异步函数的实现方式，不可能有两个线程**同时**访问相同的数据。所以，在代码访问异步函数中包含的数据时不需要线程同步。

不需要线程同步是最理想的情况，因为线程同步存在许多问题。第一个问题是它比较繁琐，而且很容易写错。在你的代码中，必须标识出所有可能由多个线程同时访问的数据。然后，必须用额外的代码将这些代码包围起来，并获取和释放一个线程同步锁。锁的作用是确保一次只有一个线程访问资源。只要有一个代码块忘记用锁包围，数据就会损坏。另外，没有办法证明你已正确添加了所有锁定代码。只能运行应用程序，对它进行大量压力测试，并寄希望于没有什么地方出错。事实上，应该在 CPU (或 CPU 内核)数量尽可能多的机器上测试应用程序。因为 CPU 越多，两个或多个线程同时访问资源的机率越大，越容易检测到问题。

锁的第二个问题在于，它们会损害性能。获取和释放锁是需要时间的，因为要调用一些额外的方法，而且不同的 CPU 必须进行协调，以决定哪个线程先取得锁。让机器中的 CPU 以这种方式相互通信，会对性能造成影响。例如，假定使用以下代码将一个节点添加到链表头：

```C#
// 这个类由 LinkedList 类使用
public class Node {
    internal Node m_next;
    // 其他成员未列出
}

public sealed class LinkedList {
    private Node m_head;

    public void Add(Node newNode) {
        // 以下两行执行速度非常快的引用赋值
        newNode.m_next = m_head;
        m_head = newNode;
    }
}
```

这个 `Add` 方法执行两个速度很快的引用赋值。现在假定要使 `Add` 方法线程安全，使多个线程能同时调用它而不至于损坏链表。这需要让 `Add` 方法获取和释放一个锁：

```C#
public sealed class LinkedList {
    private SomeKindOfLock m_lock = new SomeKindOfLock();
    private Node m_head;

    public void Add(Node newNode) {
        m_lock.Acquire();
        // 以下两行执行速度非常快的引用赋值
        newNode.m_next = m_head;
        m_head = newNode;
        m_lock.Release();
    }
}
```

`Add` 虽然线程安全了，但速度也显著慢下来了。具体慢多少要取决于所选的锁的种类；本章和下一章会对比各种锁的性能。但即便是最快的锁，也会造成 `Add` 方法数倍地慢于没有任何锁的版本。当然，如果代码在一个循环中调用 `Add` 向链表插入几个节点，性能还会变得更差。

线程同步锁的第三个问题在于，它们一次只允许一个线程访问资源。这是锁的全部意义之所在，但也是问题之所在，因为阻塞一个线程会造成更多的线程被创建。例如，假定一个线程池线程试图获取一个它暂时无法获取的锁，线程池就可能创建一个新线程，使 CPU 保持“饱和”。如同第 26 章“线程基础” 讨论的那样，创建线程时一个昂贵的操作，会耗费大量内存和时间。更不妙的是，当阻塞的线程再次运行时，它会和这个新的线程池线程共同运行。也就是说，Windows 现在要调度比 CPU 数量更多的线程，这会增大上下文切换的机率，进一步损害到性能。

综上所述，线程同步是一件不好的事情，所以在设计自己的应用程序时，应该尽可能地避免进行线程同步。具体就是避免使用像静态字段这样的共享数据。线程用 `new` 操作符构造对象时，`new` 操作符会返回对新对象的引用。在这个时刻，只要构造对象的线程才有对它的引用；其他任何线程都不能访问那个对象。如果能避免将这个引用传给可能同时使用对象的另一个线程，就不必同步对该对象的访问。

可试着使用值类型，因为它们总是被复制，每个线程操作的都是它自己的副本。最后，多个线程同时对共享数据进行只读访问是没有任何问题的。例如，许多应用程序都会在它们初始化期间创建一些数据结构。初始化完成后，应用程序就可以创建它希望的任何数量的线程；如果所有线程都只是查询数据，那么所有线程都能同时查询，无需获取或释放一个锁。`String` 类型便是这样一个例子：一旦创建好 `String` 对象，它就是“不可变”(immutable)的。所以，许多线程能同时访问一个 `String` 对象，`String` 对象没有被破坏之虞。

## <a name="29_1">29.1 类库和线程安全</a>

现在，我想简单地谈一谈类库和线程同步。Microsoft 的 Framework Class Library(FCL)保证所有静态方法都是线程安全的。这意味着假如两个线程同时调用一个静态方法，不会发生数据被破坏的情况。FCL 必须在内部做到这一点，因为开发不同程序集的多个公司不可能事先协商好使用一个锁来仲裁对资源的访问。`Console` 类包含了一个静态字段，类的许多方法都要获取和释放这个字段上的锁，确保一次只有一个线程访问控制台。

要郑重声明的是，使一个方法线程安全，并不是说它一定要在内部获取一个线程同步锁。线程安全的方法意味着在两个线程试图同时访问数据时，数据不会被破坏。`System.Math` 类有一个静态 `Max` 方法，它像下面这样实现：

```C#
public static Int32 Max(Int32 val1, Int32 val2) {
    return (val1 < val2) ? val2 : val1;
}
```

这个方法是线程安全的，即使它没有获取任何锁。由于 `Int32` 是值类型，所以传给 `Max` 的两个 `Int32` 值会复制到方法内部。多个线程可以同时调用 `Max` 方法，每个线程处理的都是它自己的数据，线程之间互不干扰。

另一方面，FCL 不保证实例方法是线程安全的，因为假如全部添加锁定，会造成性能的巨大损失。另外，假如每个实例方法都需要获取和释放一个锁，事实上会造成最终在任何给定的时刻，你的应用程序只有一个线程在运行，这对性能的影响是显而易见的。如前所述，调用实例方法时无需线程同步。然而，如果线程随后公开了这个对象引用————把它放到一个静态字段中，把它作为状态实参传给一个 `ThreadPool.QueueUserWorkItem` 或 `Task` ———— 那么在多个线程可能同时进行非读只读访问的前提下，就需要线程同步。

建议你自己的类库也遵循 FCL 的这个模式；也就是说，使自己的所有静态方法都线程安全，使所有实例方法都非线程安全。这个模式有一点要注意：如果实例方法的目的是协调线程，则实例方法应该是线程安全的。例如，一个线程可能调用 `CancellationTokenSource` 的 `Cancel` 方法取消一个操作，另一个线程通过查询对应的 `CancellationToken` 的 `IsCancellationRequested` 属性，检测到它应该停止正在做的事情。这两个实例成员内部通过一些特殊的线程同步代码来协调两个线程。<sup>①</sup>

> ① 具体地说，两个成员访问的字段被标记为 `volatile`，这是本章稍后要讨论的一个概念。

## <a name="29_2">29.2 基元用户模式和内核模式构造</a>

本章将讨论基元线程同步构造。**基元**(primitive)是指可以在代码中使用的最简单的构造。有两种基元构造；用户模式(user-mode)和内核模式(kernel-mode)。应尽量使用基元用户模式构造，它们的速度要显著快于内核模式的构造。这是因为它们使用了特殊 CPU 指令来协调线程。这意味着协调是在硬件中发生的(所以才这么快)。但这也意味着 Microsoft Windows 操作系统永远检测不到一个线程在基元用户模式的构造上阻塞了。由于在用户模式的基元构造上阻塞的线程池线程永远不认为已阻塞，所以线程池不会创建新线程来替换这种临时阻塞的线程。此外，这些 CPU 指令只阻塞线程相当短的时间。

所有这一切听起来真不错，是吧？确实如此，这是我建议尽量使用这些构造的原因。但它们也有一个缺点:只有 Windows 操作系统内核才能停止一个线程的运行(防止它浪费 CPU 时间)。在用户模式中运行的线程可能被系统抢占(preempted)，但线程会以最快的速度再次调度。所以，想要取得资源但暂时取不到的线程会一直在用户模式中“自旋”，这可能浪费大量 CPU 时间，而这些 CPU 时间本可用于执行其他更有用的工作。即便没有其他更有用的工作，更好的做法也是让 CPU 空闲，这至少能省一点电。

这使我们将眼光投向了基元内核模式构造。内核模式的构造是由 Windows 操作系统自身提供的。所以，它们要求在应用程序的线程中调用由操作系统内核实现的函数。将线程从用户模式切换为内核模式(或相反)会招致巨大的性能损失，这正是为什么要避免使用内核模式构造的原因。<sup>①</sup>但它们有一个重要的优点：线程通过内核模式的构造获取其他线程拥有的资源时，Windows 会阻塞线程以避免它浪费 CPU 时间。当资源变得可用时，Windows 会恢复线程，允许它访问资源。

> ① 29.4.1 节 “Event 构造” 最后会通过一个程序来具体测试性能。

对于在一个构造上等待的线程，如果拥有这个构造的线程一直不释放它，前者就可能一直阻塞。如果是用户模式的构造，线程将一直在一个 CPU 上运行，我们称为“活锁”(deadlock)。两种情况都不好。但在两者之间，死锁总是优于活锁，因为活锁既浪费 CPU 时间，又浪费内存(线程栈等)，而死锁只浪费内存。<sup>②</sup>

> ② 之所以说分配给线程的内存被浪费了，是因为在线程没有取得任何进展的前提下，这些内存不会差生任何收益。

我理想中的构造应兼具两者的长处。也就是说，在没有竞争的情况下，这个构造应该快而且不会阻塞(就像用户模式的构造)。但如果存在对构造的竞争，我希望它被操作系统内核阻塞。像这样的构造确实存在；我把它们称为**混合构造**(hybrid construct)，将在第 30 章详细讨论。应用程序使用混合构造是一种很常见的现象，因为在大多数应用程序中，很少会有两个或多个线程同时访问相同的数据。混合构造使你的应用程序在大多数时间都快速运行，偶尔运行得比较慢是为了阻塞线程。但这时慢一些不要紧，因为线程反正都要阻塞。

CLR 的许多线程同步构造实际只是 "Win32 线程同步构造" 的一些面向对象的类包装器。毕竟，CLR 线程就是 Windows 线程，这意味着要由 Windows 调度线程和控制线程同步。Windows 线程同步构造自 1992 年便存在了，人们已就这个主题撰写了大量内容。<sup>①</sup>所以，本章只是稍微提及了一下它。

> ① 事实上，在 Christophe Nasarre 和我合写的 《Windows 核心编程(第 5 版)》中，有几章就是专门讲这个主题的。

## <a name="29_3">29.3 用户模式构造</a>

CLR 保证对以下数据类型的变量的读写是原子性的：`Boolean`，`Char`，`(S)Byte`，`(U)Int16`，`(U)Int32`，`(U)IntPtr`，`Single` 以及引用类型。这意味着变量中的所有字节都一次性读取或写入。假如，假定有以下类：

```C#
internal static class SomeType {
    public static Int32 x = 0;
}
```

然后，如果一个线程执行这一行代码：

`SomeType.x = 0x01234567;`

`x` 变量会一次性(原子性)地从 `0x00000000` 变成 `0x01234567`。另一个线程不可能看到出于中间状态的值。例如，不可能有别的线程查询 `SomeType.x` 并得到值 `0x01230000`。假定上述 `SomeType` 类中的 `x` 字段是一个 `Int64`，那么当一个线程执行以下代码时：

`SomeType.x = 0x0123456789abcdef;`

另一个线程可能查询 `x`，并得到值 `0x0123456700000000` 或 `0x0000000089abcdef` 值，因为读取和写入操作不是原子性的。这称为一次 torn read<sup>②<sup>。

> ② 一次读取被撕成两半。或者说在机器级别上，要分两个 MOV 指令才能读完。 ———— 译注

虽然对变量的原子访问可保证读取或写入操作一次性完成，但由于编译器和 CPU 的优化，不保证操作 **什么时候** 发生。本节讨论的基元用户模式构造用于规划好这些原子性读取/写入 操作的时间。此外，这些构造还可强制对 `(U)Int64` 和 `Double` 类型的变量进行原子性的、规划好了时间的访问。

有两种基元用户模式线程同步构造。

* **易变<sup>③</sup>构造(volatile construct)**  
  在特定的时间，它在包含一个简单数据类型的变量上执行原子性的读或写操作。

* **互锁构造(interlocked construct)**  
  在特定的时间，它在包含一个简单数据类型的变量上执行原子性的读和写操作。

> ③ 文档将 volatile 翻译为 “可变”。其实它是 “短暂存在”、“易变”的意思，因为可能多个线程都想对这种字段进行修改，本书采用“易变”。 ————译注

所有易变和互锁构造都要求传递对包含简单数据类型的一个变量的引用(内存地址)。

### 29.3.1 易变构造

早期软件是用汇编语言写的。汇编语言非常繁琐，程序员要事必躬亲，清楚地指明：将这个 CPU 寄存器用于这个，分支到那里，通过这个来间接调用等。为了简化编程，人们发明个了更高级的语言。这些高级语言引入了一系列常规构造，比如 `if/else`、`switch/case`、各种循环、局部变量、实参、虚方法调用、操作符重载等。最终，这些语言的编译器必须将高级构造转换成低级构造，使计算机能真正做你想做的事情。

换言之，C# 编译器将你的 C# 构造转换成中间语言(IL)。然后，JIT 将 IL 转换成本机 CPU 指令，然后由 CPU 亲自处理这些指令。此外，C# 编译器、JIT编译器、甚至 CPU 本身都可能优化你的代码。例如，下面这个荒谬的方法在编译之后会消失得无影无踪：

```C#
private static void OptimizedAway() {
    // 常量表达式在编译时计算，结果是 0
    Int32 value = (1 * 100) - (50 * 2);

    // 如果 value 是0，循环永远不执行
    for (Int32 x = 0; x < value; x++) {
        // 不需要编译循环中的代码，因为永远都执行不到
        Console.WriteLine("Jeff");
    }
}
```

在上述代码中，编译器发现 `value` 始终是 `0`；所以循环永远不会执行，没有必要编译循环中的代码。换言之，这个方法在编译后会被“优化掉”。事实上，如果一个方法调用了 `OptimizedAway`， 在对那个方法进行 JIT 编译时，JIT 编译器会尝试内联(嵌入)`OptimizedAway` 方法的代码。但由于没有代码，所以 JIT 编译器会删除调用 `OptimizedAway` 的代码。我们喜爱编译器的这个功能。作为开发人员，我们应该以最合理的方式写代码。代码应该容易编写、阅读和维护。然后，编译器将我们的意图转换成机器能理解的代码。在这个过程中，我们希望编译器能有最好的表现。

C# 编译器、JIT 编译器和 CPU 对代码进行优化时，它们保证我们的意图会得到保留。也就是说，从单线程的角度看，方法会做我们希望它做的事情，虽然做的方式可能有别于我们在源代码中描述的方式。但从多线程的角度看，我们的意图并不一定能得到保留。下例演示了在优化之后，程序的工作方式和我们预想的有出入：

```C#
internal static class StrangeBehavior {
    // 以后会讲到，将这个字段标记成 volatile 可修正问题
    private static Boolean s_stopWorker = false;

    public static void Main() {
        Console.WriteLine("Main: letting worker run for 5 seconds");
        Thread t = new Thread(Worker);
        t.Start();
        Thread.Sleep(5000);
        s_stopWorker = true;
        Console.WriteLine("Main: waiting for worker to stop");
        t.Join();
    }

    private static void Worker(Object o) {
        Int32 x = 0;
        while (!s_stopWorker) x++;
        Console.WriteLine("Worker: stopped when x={0}", x);
    }
}
```

在上述代码中，`Main` 方法创建一个新线程来执行 `Worker` 方法。`Worker` 方法会一直数数，直到被告知停止。`Main` 方法允许 `Worker` 线程运行 5 秒，然后将静态 `Boolean` 字段设为 `true` 来告诉它停止。在这个时候，`Worker` 线程应显示它数到多少了，然后线程终止。`Main` 线程通过调用 `Join` 来等待 `Worker` 线程终止，然后 `Main` 线程返回，造成整个进程终止。

``````````````````````

## <a name="29_4">29.4 内核模式构造</a>